

<a name=/world/var/movement_mode>
<h2>movement_mode var (world)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/atom/var/appearance_flags>appearance_flags var (atom)</a>
<dd><a href=#/atom/proc/Enter>Enter proc (atom)</a>
<dd><a href=#/atom/proc/Exit>Exit proc (atom)</a>
<dd><a href=#/atom/proc/Cross>Cross proc (atom)</a>
<dd><a href=#/atom/proc/Uncross>Uncross proc (atom)</a>
<dd><a href=#/{notes}/pixel-movement>Pixel movement</a>
<dd><a href=#/{notes}/gliding>Gliding</a>
</dl>

<dl><dt><b>Possible values:</b>
<dd><tt>LEGACY_MOVEMENT_MODE</tt>: Old BYOND behavior regarding pixel movement and turf contents (see below)
<dd><tt>TILE_MOVEMENT_MODE</tt>: All atoms are locked to the tile grid
<dd><tt>PIXEL_MOVEMENT_MODE</tt>: All movable atoms can use pixel movement unless otherwise specified (see below), but legacy behavior for turf contents is ignored
</dl>

<dl class=codedd><dt><b>Default value:</b>
<dd>LEGACY_MOVEMENT_MODE
</dl>

<p>Controls how movement works on the map.

<p><tt>TILE_MOVEMENT_MODE</tt> allows you to easily discard any and all pixel
movement, so if step_x or step_y coordinates or unexpected atom bounds were
loaded from a savefile, for instance, they would be eliminated. If you use any
other movement mode, you can give an atom the
<a class=code href=#/atom/var/appearance_flags>TILE_MOVER</a> flag and it will
behave as if it were in this mode, while other atoms are free to do their own
thing.

<p><tt>LEGACY_MOVEMENT_MODE</tt> exists to distinguish between old and new
movement behavior. In older versions of BYOND before pixel movement, turfs
took their contents into consideration by default in Enter() and Exit(). This
doesn't really make sense for newer games, so in any other movement mode the
turf behavior will ignore its contents. mob.Cross() is also affected, since
it would return 0 by default in legacy mode when both mobs were dense; now
by default it checks <tt>mob.group</tt>.

