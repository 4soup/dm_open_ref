

<a name=/{notes}/regex toc="Regular expressions">
<h2>Regular expressions</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/proc/regex>regex proc</a>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/replacetext>replacetext proc</a>
<dd><a href=#/proc/splittext>splittext proc</a>
<dd><a href=#/proc/REGEX_QUOTE>REGEX_QUOTE proc</a>
</dl>

<p>Regular expressions are patterns that can be searched for within a text
string, instead of searching for an exact match to a known piece of text.
They are much more versatile for find and replace operations, and therefore
useful for parsing, filtering, etc.

<p>Some example regular expressions are:

<table class="regex">
<tr><th>Pattern</th><th>Code</th><th>Meaning</th></tr>
<tr><td>B.*D</td><td>regex("B.*D")</td><td>Find <tt>B</tt>, followed by any number of characters (including none), followed by a <tt>D</tt>.</td></tr>
<tr><td>[0-3]</td><td>regex(@"[0-3]")</td><td>Find any digit from 0 to 3</td></tr>
<tr><td>foo|bar</td><td>regex("foo|bar","i")</td><td>Find <tt>foo</tt> or <tt>bar</tt>, case-insensitive</td></tr>
<tr><td>\d+</td><td>regex(@"\d+","g")</td><td>Find all sequences of digits</td></tr>
</table>

<p>These are some of the patterns you can use. If you want to use any of the
operators as an actual character, it must be escaped with a backslash.

<p>It is highly recommended that you use <a href=#/DM/text>raw strings</a>
like <code>@"..."</code> for your regular expression patterns, because with a
regular DM string you have to escape all backslash <code>\</code> and open
bracket <code>[</code> characters, which will make your regular expression
much harder for you to read. It's easier to write <code>@"[\d]\n"</code> than
<code>"\[\\d]\\n"</code>.

<table class="regex">
<tr><th>Pattern</th><th>Matches</th></tr>
<tr><td><i>a</i>|<i>b</i></td><td><i>a</i> or <i>b</i></td></tr>
<tr><td>.</td><td>Any character (except a line break)</td></tr>
<tr><td>^</td><td>Beginning of text; or line if <tt>m</tt> flag is used</td></tr>
<tr><td>$</td><td>End of text; or line if <tt>m</tt> flag is used</td></tr>
<tr><td>\A</td><td>Beginning of text</td></tr>
<tr><td>\Z</td><td>End of text</td></tr>
<tr><td>[<i>chars</i>]</td><td>Any character between the brackets. Ranges can be specified with a hyphen, like 0-9. Character classes like <tt>\d</tt> and <tt>\s</tt> can also be used (see below).</td></tr>
<tr><td>[^<i>chars</i>]</td><td>Any character NOT matching the ones between the brackets.</td></tr>
<tr><td>\b</td><td>Word break</td></tr>
<tr><td>\B</td><td>Word non-break</td></tr>
<tr><td>(<i>pattern</i>)</td><td>Capturing group: the pattern must match, and its contents will be captured in the group list.</td></tr>
<tr><td>(?:<i>pattern</i>)</td><td>Non-capturing group: Match the pattern, but do not capture its contents.</td></tr>
<tr><td>\1 <i>through</i> \9</td><td>Backreference; <tt>\<i>N</i></tt> is whatever was captured in the <i>N</i>th capturing group.</td></tr>

<tr><th colspan=2>Modifiers</th></tr>
<tr><td colspan=2>Modifiers are "greedy" by default, looking for the longest match possible.  When following a word, they only apply to the last character.</td></tr>
<tr><td><i>a</i>*</td><td>Match <i>a</i> zero or more times</td></tr>
<tr><td><i>a</i>+</td><td>Match <i>a</i> one or more times</td></tr>
<tr><td><i>a</i>?</td><td>Match <i>a</i> zero or one time</td></tr>
<tr><td><i>a</i>{<i>n</i>}</td><td>Match <i>a</i>, exactly <i>n</i> times</td></tr>
<tr><td><i>a</i>{<i>n</i>,}</td><td>Match <i>a</i>, <i>n</i> or more times</td></tr>
<tr><td><i>a</i>{<i>n</i>,<i>m</i>}</td><td>Match <i>a</i>, <i>n</i> to <i>m</i> times</td></tr>
<tr><td><i>modifier</i>?</td><td>Make the previous modifier non-greedy (match as little as possible)</td></tr>

<tr><th colspan=2>Escape codes and character classes</th></tr>
<tr><td>\x<i>NN</i></td><td>Escape code for a single character, where <i>NN</i> is its hexadecimal ASCII value</td></tr>
<tr><td>\u<i>NNNN</i></td><td>Escape code for a single 16-bit Unicode character, where <i>NNNN</i> is its hexadecimal value</td></tr>
<tr><td>\U<i>NNNNNN</i></td><td>Escape code for a single 21-bit Unicode character, where <i>NNNNNN</i> is its hexadecimal value</td></tr>
<tr><td>\d</td><td>Any digit 0 through 9</td></tr>
<tr><td>\D</td><td>Any character except a digit or line break</td></tr>
<tr><td>\l</td><td>Any letter A through Z, case-insensitive</td></tr>
<tr><td>\L</td><td>Any character except a letter or line break</td></tr>
<tr><td>\w</td><td>Any identifier character: digits, letters, or underscore</td></tr>
<tr><td>\W</td><td>Any character except an identifier character or line break</td></tr>
<tr><td>\s</td><td>Any space character</td></tr>
<tr><td>\S</td><td>Any character except a space or line break</td></tr>

<tr><th colspan=2>Assertions</th></tr>
<tr><td>(?=<i>pattern</i>)</td><td>Look-ahead: Require this pattern to come next, but don't include it in the match</td></tr>
<tr><td>(?!<i>pattern</i>)</td><td>Look-ahead: Require this pattern NOT to come next</td></tr>
<tr><td>(?&lt;=<i>pattern</i>)</td><td>Look-behind: Require this pattern to come before, but don't include it in the match (must be a fixed byte length)</td></tr>
<tr><td>(?&lt;!<i>pattern</i>)</td><td>Look-behind: Require this pattern NOT to come before (must be a fixed byte length)</td></tr>
</table>

<p>The optional flags can be any combination of these:

<table class="regex">
<tr><th>Flag</th><th>Meaning</th></tr>
<tr><td>i</td><td>Case-insensitive matching</td></tr>
<tr><td>g</td><td>Global: In Find() subsequent calls will start where this left off, and in Replace() all matches are replaced.</td></tr>
<tr><td>m</td><td>Multi-line: ^ and $ refer to the beginning and end of a line, respectively.</td></tr>
</table>

<p>After calling <tt>Find()</tt> on a <tt>/regex</tt> datum, the datum's
<tt>group</tt> var will contain a list&mdash;if applicable&mdash;of any
sub-patterns found with the <tt>()</tt> parentheses operator. For instance,
searching the string <tt>"123"</tt> for <tt>1(\d)(\d)</tt> will match
<tt>"123"</tt>, and the <tt>group</tt> var will be <tt>list("2","3")</tt>.
Groups can also be used in replacement expressions; see the
<a class=code href=#/regex/proc/Replace>Replace() proc</a> for more details.

