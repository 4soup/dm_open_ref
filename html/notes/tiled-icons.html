

<a name=/{notes}/tiled-icons toc="Tiled icons">
<h2>Tiled icons</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon>icon</a>
<dd><a href=#/icon/proc>procs (icon)</a>
<dd><a href=#/world/var/map_format>map_format var (world)</a>
<dd><a href=#/world/var/icon_size>icon_size var (world)</a>
<dd><a href=#/{notes}/big-icons>Big icons</a>
</dl>

<p>In BYOND 3.0, any file like a large .bmp would be treated like a regular
icon that had been broken up into several tile-sized icon states. All tiles
then were 32x32 pixels. An image that was 100x100 would therefore take at
least 4x4 tiles to display. The icon was padded to the right and the top with
blank space to become an even multiple of 32x32, and then broken up into
sections. The lower left section was given an icon_state of <tt>"0,0"</tt>,
the next to the right was <tt>"1,0"</tt>, and so on, up to the upper right
which was <tt>"3,3"</tt>. Another icon state, a 32x32 thumbnail of the big
image, was also included.

<p>BYOND 4.0 expanded on this concept by allowing icons to be defined that had
individual graphics bigger than 32x32, and it would break each one up into
tiles just like 3.0 did. If an icon had a state called <tt>"open"</tt> then it
might break down into <tt>"open 0,0"</tt>, <tt>"open 1,0"</tt>, and so on,
while the actual <tt>"open"</tt> state would be a thumbnail image. To show the
whole image, you would have to have a separate atom or overlay for each
individual tile.

<p>In newer versions, breaking big icons into tiles is no longer done by
default. Instead, icons are shown and manipulated in their
<a href=#/{notes}/big-icons>native size</a>. To use the old method of breaking
icons into tiles, set <tt>world.map_format</tt> to <tt>TILED_ICON_MAP</tt>.
This is the default for all projects compiled before version 455.

<p>When using tiled icons, there are some important things to note:

<ul>
  <li>You need to use extra atoms or overlays to show any icon bigger than a
    single tile, where each atom/overlay shows an individual tile-sized piece
    of the big icon.</li>
  <li>The icon_state names of each tile are always the original name followed
    by a space, followed by x,y tile coordinates such as 0,0 or 2,1, so the
    northeast corner of <tt>"flag"</tt> might for instance be
    <tt>"flag 3,2"</tt>. If the original icon_state had no name, the space is
    left out and only the x,y coordinates are used.</li>
  <li>Every icon's size is a multiple of world.icon_size. If an icon of an
    incompatible size is used, it will be padded to the nearest full tile
    size.</li>
  <li><tt>Crop()</tt> and <tt>Scale()</tt> always pad their results to the
    nearest full tile size.</li>
  <li><tt>icon.Insert()</tt> can insert a single-tile icon into a multi-tiled
    big icon using the appropriate icon_state; e.g., inserting into
    <tt>"door 0,0"</tt> will replace the southwest corner of the
    <tt>"door"</tt> state.</li>
  <li>Using the <tt>icon()</tt> proc, you can extract a single tile from a
    multi-tiled big icon.</li>
</ul>

<p>This example shows a big icon being applied to an atom in tiled mode, as
overlays:

<h3>Example:</h3>
<xmp>
// icon is 3 tiles wide by 2 high
icon_state = "0,0"

// A temporary object used for the overlays
var/obj/O = new
O.icon = icon
O.layer = FLOAT_LAYER

for(var/tile_y=0, tile_y<2, ++tile_y)
   for(var/tile_x=0, tile_x<3, ++tile_x)
      if(tile_x && tile_y)
         O.pixel_x = tile_x * 32
         O.pixel_y = tile_y * 32
         O.icon_state = "[tile_x],[tile_y]"
         overlays += O
</xmp>

