

<a name=/regex/proc/Find>
<h2 byondver=510>Find proc (regex)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/{notes}/regex>Regular expressions</a>
<dd><a href=#/regex>regex datum</a>
<dd><a href=#/regex/proc/Replace>Replace proc (regex)</a>
<dd><a href=#/regex/var>regex vars</a>
<dd><a href=#/proc/regex>regex proc</a>
<dd><a href=#/proc/findtext>findtext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>Find(haystack, Start=1, End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The position of the matched text, or 0 if no match was found.
</dl>

<dl><dt><b>Args:</b>
<dd>haystack: The text to be searched
<dd>Start: The start position (in bytes) to search; defaults to 1, or to src.next if this is a global pattern
<dd>End: The position of the byte after the end of the search; 0 is the end. The actual match is allowed to extend past End.
</dl>

<p>Finds the regular expression pattern within the "haystack" text.  The
following vars are set by the match:

<ul>
<li>text: The text that was searched.</li>
<li>index: The index where the match was found (same as the return value)</li>
<li>match: The actual matched text</li>
<li>group: If the expression contains capturing groups with the ( ) parentheses operator, this is a list that holds the text found in those groups. group[1] is the first group, and so on.</li>
<li>next: If the "g" flag was used to create thie expression, this is the next index to begin searching.
</ul>

<p>In a global expression (using the "g" flag), Find() can be called
repeatedly on the same piece of text and the Start position will be advanced
automatically unless you specify it.

<p>Note: In strings containing non-ASCII characters, byte position and
character position are not the same thing. Use <tt>Find_char()</tt> to
work with character counts instead of bytes, at a performance cost. See the
<a href=@/{notes}/Unicode>Unicode</a> section for more information.

