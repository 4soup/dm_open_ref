

<a name=/proc/continue>
<h2>continue statement</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/break>break statement</a>
<dd><a href=#/proc/do>do proc</a>
<dd><a href=#/proc/for/loop>for loop proc</a>
<dd><a href=#/proc/while>while proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>continue
<dd>continue Label
</dl>

<p>Begins the next iteration of the loop with the given label.  If no label
is specified, the innermost loop containing the continue statement is
assumed.

<p>In a <tt>for(Init,Test,Inc)</tt> loop, the <tt>continue</tt> statement will
jump to the <tt>Inc</tt> portion (if any) and move on to the conditional
<tt>Test</tt>. In a <tt>for(item in list)</tt> loop, it will skip to the
next item in the list. In a <tt>while</tt> or <tt>do-while</tt> loop,
<tt>continue</tt> jumps to the condition in the <tt>while</tt> statement.

<h3>Example:</h3>
<xmp>
client/verb/who()
  var/mob/M
  usr << "Players:"
  for(M in world)
    if(M == usr) continue
    if(M.key) usr << M.key
</xmp>

<p>This displays a list of players who have a mob in the world.  The
<code>continue</code> statement is used here to avoid including the user in
the list.  The same thing could have been achieved by using only the
<code>if</code> statement.  In more complicated situations, however, very
long conditional expressions and deeply nested <code>if</code> statements
can be avoided by using <code>continue</code> and its companion
<code>break</code>.

<p>Here is an example using a label to continue an outer loop from inside an
inner one:  <xmp> client/verb/loners()
  var/mob/M
  var/mob/G

  usr << "Loners:"
  finding_loners:
    for(M in world)
      for(G in world)
        if(M in G.group) continue finding_loners

      //found a loner
      usr << M.name
</xmp>

<p>This displays a list of mobs who do not belong in anyone else's group.
Notice the syntax for labeling a list.  The name of the block is simply
placed in the code followed by a colon and its contents are indented inside
it.

