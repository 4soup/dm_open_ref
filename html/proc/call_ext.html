

<a name=/proc/call_ext>
<h2 byondver=515>call_ext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/load_ext>load_ext proc</a>
<dd><a href=#/proc/arglist>arglist proc</a>
<dd><a href=#/proc/call>call proc</a>
<dd><a href=#/operator/path>path operators</a>
<dd><a href=#/{{appendix}}/Byondapi>Byondapi</a>
</dl>

<dl><dt><b>Format:</b>
<dd>call_ext(LibName,FuncName)(Arguments)
<dd>call_ext(LoadedFunc)(Arguments)
</dl>

<dl><dt><b>Args:</b>
<dd>LibName: name of external library ("test.DLL") (note: the .dll or .so suffix is not required)
<dd>FuncName: name of function in external library ("func"), which may have prefixes to describe the type of function
<dd>LoadedFunc: reference to a function that was loaded via <tt>load_ext()</tt>
</dl>

<dl><dt><b>Returns:</b>
<dd>The return value of the external library function.
</dl>

<p>This instruction exists in order to access third-party libraries (.DLL
files on Windows, .SO files on Unix), as long as the one or more of the
following conditions is met:
<ul>
<li>The library is located in the BYOND user <tt>bin/</tt> folder
(<tt>~/.byond/bin</tt> on Unix, typically
<tt>%APPDATA%/Documents/BYOND/bin/</tt> on Windows).  This is intended to
allow the user to install permanently "trusted" libraries. <b><i>OR</i></b></li>
<li>The server is run in <tt>-trusted</tt> mode. <b><i>OR</i></b></li>
<li>The server grants permission to access the library at runtime, through a
prompt query.</li>
</ul> 

<p>If the library access or lookup fails for any reason, a runtime error will
be thrown.

<p>Normally you use LibName and FuncName, and <tt>call_ext()</tt> will look up
the function for you. However you can save a little time by using
<tt>load_ext()</tt>, which will do the lookup once and let you reuse the
reference to that function as often as you need to, which should be helpful for
performance-hungry code.

<h3>String version</h3>

<p>The standard way of making external calls (and until version 515, the only
way) uses strings for everything. Any arguments that are not strings are
passed as empty strings instead. The call is prototyped in the DLL this way:

<pre class=cpp>
extern "C" char *func(unsigned int argc, char *argv[]);
</pre>

<p>The <tt>argc</tt> argument is a number of arguments, and <tt>argv</tt> is
an array of the arguments themselves. The integer must be 32-bit.

<p>As the library prototype is <tt>char**</tt>, the <tt>call_ext()</tt>
arguments must be strings. Other types (like numbers) will be passed as the
empty string (<tt>""</tt>) into the library function.

<h3 class=cpp>Example:</h3>
<pre class=cpp>
// test.dll, a win32 C++ library compiled in VC++:
#include &lt;string.h&gt;
// This is an example of an exported function.
// Windows requires __declspec(dllexport) to be used to declare public symbols
// The name of the function from within the dll may be compiler-dependent
// (in this case it will usually be "merge" or "_merge").
// Google "name decoration" for more information on this exciting topic.
extern "C" __declspec(dllexport) char *merge(int n, char *v[]) 
{
    static char buf[500]; 
    *buf=0;
    for(int i=0; i&lt;n; i++) {
        strcat(buf,v[i]); // we should bounds-check but it's a stupid example!
    }
    return buf;
}
</pre>

<xmp>
// DM code to use test.dll
mob/verb/test()
    usr << call_ext("test.dll","merge")("fee","fi","fo") // returns "feefifo"

// As with the other call() versions, arglist() may be used to do runtime arguments:
mob/verb/argtest()
    var/L = list("fee","fi","fo")
    usr << call_ext("test.dll","func")(arglist(L)) // returns "feefifo"
</xmp>

<p>The <tt>char *</tt> pointer returned by the library is expected to be
cleaned up by the library when it's unloaded, or it can be cleaned up on a
subsequent function call. BYOND makes a copy of the string when the function
returns and does not need it after that.

<h3 byondver=515>Byondapi version</h3>

<p>A newer and more flexible way of calling external libraries is now
available, and it allows you to pass strings, numbers, and references, and
also get other types of valus in return. This uses
<a href=#/{{appendix}}/Byondapi>Byondapi</a> and requires your external
library to be compiled with the <tt>byondapi.h</tt> header file (if using C
or C++). Byondapi also includes helpful C++ wrapper classes in separate files.

<p>With Byondapi calls, the function name you use in <tt>call_ext()</tt>
should be prefixed by <tt>byond:</tt> so that the engine knows what type of
function it is. In your library, the call is prototyped like so:

<pre class=cpp>
extern "C" CByondValue func(u4c argc, CByondValue argv[]);
</pre>

<p>The <tt>u4c</tt> type is an unsigned 32-bit integer, defined in
<tt>byondapi.h</tt>. <tt>CByondValue</tt> is also defined there. Interacting
with a CByondValue structure requires the functions exported as part of
Byondapi.

<h3 class=cpp>Example:</h3>
<pre class=cpp>
// test_byondapi.dll, a win32 C++ library compiled in VC++:
#include &lt;byondapi.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

// a different take on the merge example above
extern "C" BYOND_EXPORT CByondValue merge(int n, CByondValue v[])
{
    CByondValue result;
    u4c buflen = 1024;  // initial size of buffer
    u4c totallen = 0;   // length of total string so far (not including trailing null)
    char *buf = (char*)malloc(buflen);

    if(!buf) {  // we couldn't allocate memory
        ByondValue_Clear(&result);
        return result;
    }

    for(int i=0; i&lt;n; i++) {
        u4c len = buflen - totallen;    // # of bytes left in buffer
        bool success = Byond_ToString(v[i], buf+totallen, &len);
        // on success, len is filled with # of bytes written (including trailing null)
        if(success) {
            totallen += (len-1);
        }
        // if we failed but len > 0, it's the new size of the buffer we need
        else if(len) {
            len = (len + 1023) & ~1023; // round up to 1K increments
            char *newbuf = (char *)mallloc(len);
            if(!newbuf) {   // out of memory; stop here
                ByondValue_Clear(&result);
                return result;
            }
            memcpy(newbuf, buf, totallen+1);    // include trailing null in copy
            free(buf);
            buf = newbuf; buflen = len;
            --i;  // retry Byond_ToString() for this argument
        }
        // if we failed but len == 0, there was an error
        else {
            free(buf);
            ByondValue_Clear(&result);
            return result;
        }
    }
    ByondValue_SetStr(&result, buf);    // create a new internal string
    free(buf);  // free the buffer
    return result;
}

extern "C" BYOND_EXPORT CByondValue average(int n, CByondValue v[])
{
    CByondValue result;
    float total = 0.0f;
    int count = 0;
    for(int i=0; i&lt;n; i++) {
        if(!ByondValue_IsNum(v[i])) continue;
        total += ByondValue_GetNum(v[i]);
        ++count;
    }
    if(count) ByondValue_SetNum(&result, total / count);
    else ByondValue_Clear(&result); // return null on failure
    return result;
}
</pre>

<xmp>
// DM code to use test_byondapi.dll
mob/verb/test()
    usr << call_ext("test_byondapi","byond:merge")("fee","fi","fo") // returns "feefifo"

mob/verb/average()
    usr << call_ext("test_byondapi","byond:average")(1,6,8)  // returns 5
</xmp>

<p>You are of course allowed to mix different argument types, so they don't
all have to be numbers or all strings. Your library code can use the Byondapi
functions to interact with these values.

<h3>Other prefixes</h3>

<p>For advanced users: on Windows, <tt>call_ext()</tt> uses the <tt>__cdecl</tt>
convention by default. If you are designing or linking to a DLL that uses the
<tt>__stdcall</tt> convention instead, you can inform <tt>call_ext()</tt> by
prefacing the function name with the <tt>"@"</tt> symbol. E.g.,
<tt>call_ext("test.dll","@merge")</tt> would call a version of <tt>merge</tt>
declared with the <tt>__stdcall</tt> convention. Likewise if you use the
Byondapi version, you can use <tt>call_ext("test.dll","@byond:merge")</tt> or
<tt>call_ext("test.dll","byond:@merge")</tt> (it doesn't matter which order the
prefixes go in).

