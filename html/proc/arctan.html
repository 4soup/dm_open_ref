

<a name=/proc/arctan>
<h2 byondver=513>arctan proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/arcsin>arcsin proc</a>
<dd><a href=#/proc/arccos>arccos proc</a>
<dd><a href=#/proc/tan>tan proc</a>
<dd><a href=#/proc/turn>turn proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>arctan(Num)
<dd>arctan(x, y)
<dd>arctan(Vector)
</dl>

<dl><dt><b>Args:</b>
<dd>Num: A number
<dd>x, y: 2D coordinates
<dd>Vector: A vector (only 2 dimensions are used)
</dl>

<dl><dt><b>Returns:</b>
<dd>The inverse tangent in degrees.
</dl>

<p>When <tt>arctan</tt> is called with just one number argument, the number
is a tangent, and the return value is the angle that produces that tangent.
The resulting angle can range from -90 to 90.

<p>The two-argument form returns a polar angle from -180 to 180. This angle
starts at 0&deg; for due east, and increases counter-clockwise from there.
Therefore 1,0 has an arctangent of 0&deg;, 0,1 is 90&deg;, -1,0 is 180&deg;,
and so on. At point 0,0 the angle is undefined since it could be any angle,
but <tt>arctan</tt> will return 0.

<p>Finally, you can use a vector instead of a number. Only the x and y
components of a vector will be used.

<h3>Example:</h3>
<xmp>
mob/verb/test()
   usr << arctan(0)        // 0
   usr << arctan(1)        // 45
   usr << arctan(sqrt(3))  // 60

   // polar coordinates
   usr << arctan(3, 4)     // 53.1301
   usr << arctan(-1, 1)    // 135
   usr << arctan(0, -5)    // -90
</xmp>

<p>Here's another example, in which a rotating turret points to a target on
another tile.

<xmp>
mob/turret
   proc/PointAt(atom/target)
      if(!target) return
      var/dx = target.x - x
      var/dy = target.y - y
      // turret's icon normally faces east
      transform = matrix().Turn(-arctan(dx, dy))
</xmp>

