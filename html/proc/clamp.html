

<a name=/proc/clamp>
<h2 byondver=513>clamp proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/min>min proc</a>
<dd><a href=#/proc/max>max proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>clamp(Value, Low, High)
<dd>clamp(List, Low, High)
</dl>

<dl><dt><b>Args:</b>
<dd>Value: A number, text, pixloc, or vector (or null, treated as 0).
<dd>List: A list of values.
<dd>Low: The lowest value that can be returned.
<dd>High: The highest value that can be returned.
</dl>

<dl><dt><b>Returns:</b>
<dd>A copy of the original Value, constrained between Low and High.
<dd>The original List, whose contents have all been clamped.
</dl>

<p>"Clamps" a value, usually a number, to a given allowable range from
<tt>Low</tt> to <tt>High</tt>. If the value is already in that range, it is
unchanged. Otherwise, the closer of <tt>Low</tt> or <tt>High</tt> is returned.

<p>If the <tt>Low</tt> and <tt>High</tt> values are out of order, it doesn't
matter.

<p>This is effectively equivalent to <tt>min(max(Value, min(Low,High)),
max(Low,High))</tt>, but slightly faster.

<h3>Example:</h3>
<xmp>
usr << clamp(5, 0, 10)  // 5; it falls between 0 and 10
usr << clamp(-1, 0, 10) // 0; it is less than 0
usr << clamp(20, 0, 10) // 10; it is more than 10
</xmp>

<p>If the compared items are objects such as pixlocs or vectors, the result of
clamping them is a new object, not one of the objects that was compared.

<p>The list format will accept a list in place of a value as the first
argument, and it behaves as if you looped through the entire list and ran
<tt>clamp()</tt> on each value. Please note the original list will be
modified. If you want to leave the original list alone, use the
<a href=#/list/proc/Copy><tt>Copy()</tt> proc</a> to pass a copy to
<tt>clamp()</tt> instead.

