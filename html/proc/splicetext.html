

<a name=/proc/splicetext>
<h2 byondver=514>splicetext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/copytext>copytext proc</a>
<dd><a href=#/list/proc/Splice>Splice proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>splicetext(Text,Start=1,End=0,Insert="")
</dl>

<dl><dt><b>Returns:</b>
<dd>Spliced text
</dl>

<dl><dt><b>Args:</b>
<dd>Text: The text string to splice.
<dd>Start: The text byte position in Text where the splice will begin.
<dd>End: The text byte position in Text immediately following the last
     character to be cut from the splice. 0 is the end of the string.
<dd>Insert: Text to be inserted.
</dl>

<p>Cuts out a section of a text string and inserts a different piece of text
in its place. This is basically equivalent to <tt>copytext(Text,1,Start) +
Insert + copytext(Text,End)</tt>, but faster.

<h3>Example:</h3>
<xmp>
// cuts "nan" from "banana" and replaces it with "laclav"
// prints "balaclava"
usr << splicetext("banana", 3, 6, "laclav")
</xmp>

<p>The <tt>Start</tt> and <tt>End</tt> index values can be negative, which
count backwards from the end of the string. If the index values are out of
range, there will be no error; they will simply be clamped to the beginning
or end of the string. If <tt>End</tt> comes before <tt>Start</tt>, the two
values are swapped.

<p>Note: In strings containing non-ASCII characters, byte position and
character position are not the same thing. Use <tt>splicetext_char()</tt> to
work with character counts instead of bytes, at a performance cost. See the
<a href=#/{notes}/Unicode>Unicode</a> section for more information.

