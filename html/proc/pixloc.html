

<a name=/proc/pixloc>
<h2 byondver=516>pixloc proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/pixloc>pixloc</a>
<dd><a href=#/atom/var/pixloc>pixloc var (atom)</a>
<dd><a href=#/proc/bound_pixloc>bound_pixloc proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>pixloc(x, y, z)
<dd>pixloc(Atom)
<dd>pixloc(Atom, x, y)
<dd>pixloc(Atom, Vector)
<dd>pixloc(Pixloc)
<dd>pixloc(Pixloc, x, y)
<dd>pixloc(Pixloc, Vector)
</dl>

<dl><dt><b>Returns:</b>
<dd>A new <tt>pixloc</tt> object or null.
</dl>

<dl><dt><b>Args:</b>
<dd>x, y, z: Pixel coordinates in world space (starting at 1,1,1). When the first argument is an atom or pixloc, x and y are offsets.
<dd>Atom: An atom whose pixloc will be copied.
<dd>Pixloc: An existing pixloc to copy.
<dd>Vector: A 2D vector to offset the new pixloc by.
</dl>

<p>Creates a new <tt>pixloc</tt> object based on an existing object's
location or using raw world coordinates. If the pixloc can't be created, for
instance if the Atom argument is not directly on the map, the result is null.

<h3>Example:</h3>
<xmp>
mob/proc/GoToStrangeForest()
    // in a world with 32x32 icon size, this is x=18, y=29, step_x=5, step_y=11
    mob.pixloc = pixloc(550, 907, 1)
</xmp>

<p>When the pixloc is created with world coordinates, x and y are a
combination of tile x and step_x, and tile y and step_y, starting at a value
of 1. The world x and y for any tile and step combo can be calculated like so
(if for any reason you needed to):

<xmp>
world_x = (tile_x - 1) * pixels_per_x_tile  + step_x + 1
world_y = (tile_y - 1) * pixels_per_y_tile + step_y + 1
</xmp>

