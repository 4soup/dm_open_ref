

<a name=/proc/findtext>
<h2>findtext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findlasttext>findlasttext proc</a>
<dd><a href=#/proc/findtextEx>findtextEx proc</a>
<dd><a href=#/proc/replacetext>replacetext proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
</dl>

<dl><dt><b>Format:</b>
<dd>findtext(Haystack,Needle,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The first position of Needle in Haystack; 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for. May be a regular expression (regex).
<dd>Start: The text byte position in Haystack in which to begin the search.
<dd>End: The text byte position in Haystack immediately following the last
     character to search.
</dl>

<p>When Needle is text, this instruction is NOT sensitive to the case of
Haystack or Needle.  The case-sensitive version is findtextEx().

<h3>Example:</h3>
<xmp>
if(findtext("Hi There","there")==0)
  world << "Not found!"
else
  world << "Found!"
</xmp>

<p>This outputs "Found!", since "there" is a part of the string "Hi There",
ignoring case.

<p>If the start or end position is negative, the position is counted backwards
from the end of the string. E.g., findtext("Banana", "na", -3) starts three
characters from the end and only searches the final "ana".

<p>Note: In strings containing non-ASCII characters, byte position and
character position are not the same thing. Use <tt>findtext_char()</tt> to
work with character counts instead of bytes, at a performance cost. See the
<a href=#/{notes}/Unicode>Unicode</a> section for more information.

