

<a name=/proc/splittext>
<h2 byondver=510>splittext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/jointext>jointext proc</a>
<dd><a href=#/proc/nonspantext>nonspantext proc</a>
<dd><a href=#/proc/spantext>spantext proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
</dl>

<dl><dt><b>Format:</b>
<dd>splittext(Text,Delimiter,Start=1,End=0,include_delimiters=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A list of text strings split by the delimiter given.
</dl>

<dl><dt><b>Args:</b>
<dd>Text: The text string to search.
<dd>Delimiter: A text string that will be used as the separator between items,
     OR a regular expression (regex) used to find splits
<dd>Start: The text byte position in Text in which to begin looking for splits.
<dd>End: The text byte position in Text immediately following the last
     character to look at for splits.
<dd>include_delimiters: True if any delimiters found should be included in
     the result.
</dl>

<p>Splits up a text string and returns a list.  The delimiter is
case-sensitive (unless you use a case-insensitive regular expression), and
can be more than one character long.

<h3>Example:</h3>
<xmp>
var/list/items = splittext("apples,oranges,bananas", ",")
// prints "apples", "oranges", and "bananas" separately
for(var/item in items)
    usr << item
</xmp>

<p>Where multiple delimiters are next to each other, they're considered to be
separating an empty string.  Therefore splittext("a,,b,c", ",") would return a
list with four elements instead of three.  Splitting empty text returns an
empty list.

<p>If a regular expression is used as the delimiter, any capturing groups in
the expression will be included in the list, in order. (The whole match itself
will come first, if include_delimiters is true.) So for instance splitting by
regex(",") will not include the comma, but splitting by regex("(,)") will.
Groups that were not part of the match will be null.

<p>If the start or end position is negative, the position is counted backwards
from the end of the string. Please note that the start and end positions do
NOT trim the string; if you want to split a trimmed string, trim it with
<a class=code href=#/proc/copytext>copytext()</a> and send the result to
<tt>splittext()</tt> instead.

<p>Note: In strings containing non-ASCII characters, byte position and
character position are not the same thing. Use <tt>splittext_char()</tt> to
work with character counts instead of bytes, at a performance cost. See the
<a href=#/{notes}/Unicode>Unicode</a> section for more information.

