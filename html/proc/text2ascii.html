

<a name=/proc/text2ascii>
<h2>text2ascii proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/ascii2text>ascii2text proc</a>
<dd><a href=#/DM/text/entities>entities (text)</a>
<dd><a href=#/{notes}/Unicode>Unicode</a>
</dl>

<dl><dt><b>Format:</b>
<dd>text2ascii(T,pos=1)
</dl>

<dl><dt><b>Args:</b>
<dd>T: A text string.
<dd>pos: The byte position in T to use, starting at 1.
</dl>

<dl><dt><b>Returns:</b>
<dd>A number representing the character's ASCII or Unicode code.
</dl>

<p>ASCII codes are numerical values corresponding to keyboard and special
characters. Among other things, they are used to represent many symbols in
HTML. This proc converts a text string to its corresponding ascii
representation.

<h3>Example:</h3>
<xmp>
world << text2ascii("A")  // = 65
world << text2ascii("HAPPY",2)  // = 65
</xmp>

<p>With <a href=#/{notes}/Unicode>Unicode</a>, things may get more
complicated. DM stores text with UTF-8 encoding, so at this position there
might be several bytes strung together to make a single character. The value
of <tt>pos</tt> is in bytes, not characters. When the return value is 128
(0x80) or higher, multiple bytes are used for the charcter. In that case the
next character position is not <tt>pos + 1</tt> like it is for regular text,
but you can use <tt>pos + length(ascii2text(result))</tt> instead. Or, you
can determine the byte count from this table:

<table class=withborder>
<tr><th>Character code</th><th>Size in bytes</th></tr>
<tr><td>0 - 0x7F</td><td>1</td></tr>
<tr><td>0x80 - 0x7FF</td><td>2</td></tr>
<tr><td>0x800 - 0xFFFF</td><td>3</td></tr>
<tr><td>0x10000 - 0x10FFFF</td><td>4</td></tr>
</table>

<p>Alternatively, you can use <tt>test2ascii_char()</tt> to work with
character positions instead of bytes, at a performance cost.

