

<a name=/list/proc/Splice>
<h2 byondver=514>Splice proc (list)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/list/proc/Copy>Copy proc (list)</a>
<dd><a href=#/list/proc/Cut>Cut proc (list)</a>
<dd><a href=#/list/proc/Insert>Insert proc (list)</a>
<dd><a href=#/proc/splicetext>splicetext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>list.Splice(Start=1,End=0,Item1,Item2...)
</dl>

<dl><dt><b>Args:</b>
<dd>Start: The list index where the splice will begin.
<dd>End: The index immediately following the last item to be cut from the list. 0 is the end of the list.
<dd>Item1, Item2...: Items to be inserted.
</dl>

<p>Cuts out items from a list, and inserts new items in their place.
This is basically equivalent to calling <tt>list.Cut(Start,End)</tt> and then
calling <tt>list.Insert(Start,Item1,Item2...)</tt>, but faster.

<h3>Example:</h3>
<xmp>
var/list/L = list("apple","banana","orange","pear")

// cuts "banana" and "orange" and inserts four new items
L.Splice(2,4,"firetruck","camel","joystick","balloon")

// prints apple, firetruck, camel, joystick, balloon, pear
for(var/item in L)
    usr << item
</xmp>

<p>As with <tt>Insert()</tt>, any items that are lists will insert their
contents instead of themselves.

<p>The <tt>Start</tt> and <tt>End</tt> index values can be negative, which
count backwards from the end of the list. If the index values are out of
range, there will be no error; they will simply be clamped to the beginning
or end of the list. If <tt>End</tt> comes before <tt>Start</tt>, the two
values are swapped.

<p>Note: This proc doesn't work with many special lists such as
<code>contents</code> or <code>overlays</code>.

