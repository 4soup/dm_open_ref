

<a name=/icon>
<h2>icon object</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/icon/proc>procs (icon)</a>
<dd><a href=#/DM/icon>icons</a>
<dd><a href=#/image>image objects</a>
<dd><a href=#/{{appendix}}/stddef%2edm>stddef.dm file</a>
</dl>

<p>An <tt>/icon</tt> object is created by loading an icon file into memory for
direct access and manipulation.  In order to be displayed, an <tt>/icon</tt>
object always gets converted back into an icon file; this happens
automatically when you assign atom.icon to an <tt>/icon</tt> object, since
that variable may only refer to a static icon file, rather than a dynamic
memory object.

<p>To create an <tt>/icon</tt> object, simply use <tt>new/icon()</tt>, or the
short-cut <tt>icon()</tt> proc.  The following example loads an icon file,
reddens it, and then assigns it back to the player's icon, which implicitly
creates a new icon file.

<h3>Example:</h3>
<xmp>
mob/verb/test()
   var/icon/I = new('player.dmi')
   I.Blend(rgb(40,0,0))
   usr.icon = I
</xmp>

<p>Note that merely displaying different icon states or directions can
generally be achieved without any icon manipulation, which saves quite a bit
of overhead.  For example, the variables <tt>atom.icon_state</tt> and
<tt>atom.dir</tt> can be used to control how <tt>atom.icon</tt> is displayed,
without any need for generating a new icon file.

<p>Many things that used to require icon manipulation may not need you to do
so anymore, as DM has evolved new capabilities.

<table class=withborder>
<tr><th>Operation</th><th><tt>/icon</tt> proc</th><th>New method</th></tr>
<tr><td>Multiplying by color</td><td><a class=code href=#/icon/proc/Blend><tt>Blend</tt></a> or <a class=code href=#/icon/proc/SetIntensity>SetIntensity</a> procs</td><td><a class=code href=#/atom/var/color>color</a> var</td></tr>
<tr><td>Adding color</td><td><a class=code href=#/icon/proc/Blend>Blend</a> proc</td><td rowspan=2><a class=code href=#/atom/var/color>color</a> var (using <a href=#/{notes}/color-matrix>color matrix</a>)</td></tr>
<tr><td>Applying color matrix</td><td><a class=code href=#/icon/proc/MapColors>MapColors</a> proc</td></tr>
<tr><td>Rotation</td><td><a class=code href=#/icon/proc/Turn>Turn</a> proc</td><td rowspan=3><a class=code href=#/atom/var/transform>transform</a> var</td></tr>
<tr><td>Flipping horizontal/vertical</td><td><a class=code href=#/icon/proc/Flip>Flip</a> proc</td></tr>
<tr><td>Scaling</td><td><a class=code href=#/icon/proc/Scale>Scale</a> proc</td></tr>
<tr><td>Overlaying/underlaying another icon</td><td><a class=code href=#/icon/proc/Blend>Blend</a> proc + <tt>ICON_OVERLAY</tt></td><td>Overlay/underlay + <a class=code href=#/atom/var/appearance_flags>KEEP_TOGETHER</a><br/><a href=#/{notes}/filters/layer>Layering filter</a></td></tr>
</table>

<p class=performance>Note: Anything you can do with an atom var instead of
using icon manipulation procs will usually perform much better. Games that use
the new methods use fewer resources, use less memory, and also usually look
better too.

