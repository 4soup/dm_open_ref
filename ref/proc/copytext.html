

<a name=/proc/copytext>
<h2>copytext proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/splicetext>splicetext proc</a>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/splittext>splittext proc</a>
<dd><a href=#/proc/trimtext>trimtext proc</a>
<dd><a href=#/list/proc/Copy>Copy proc (list)</a>
</dl>

<dl><dt><b>Format:</b>
<dd>copytext(T,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>A text string.
</dl>

<dl><dt><b>Args:</b>
<dd>T:     A text string.
<dd>Start: The text byte position in which to begin the copy.
<dd>End: The text byte position immediately following the last character to be copied.
</dl>

<p>Copy characters in T between Start and End. The default end position of 0
stands for <tt>length(T)+1</tt>, so by default the entire text string is copied.

<h3>Example:</h3>
<xmp>
pre = copytext("Hi there",1,3))// = "Hi"
post = copytext("Hi there",4)) // = "there"
</xmp>

<p>If the start or end position is negative, it counts backwards from the end
of the string.

<h3>Example:</h3>
<xmp>
post = copytext("Hi there",-5)) // = "there"
</xmp>

<p>Note: In strings containing non-ASCII characters, byte position and
character position are not the same thing. Use <tt>copytext_char()</tt> to
work with character counts instead of bytes, at a performance cost. See the
<a href=#/{notes}/Unicode>Unicode</a> section for more information.

