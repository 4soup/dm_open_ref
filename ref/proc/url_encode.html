

<a name=/proc/url_encode>
<h2>url_encode proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/url_decode>url_decode proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>url_encode(PlainText, format=0)
</dl>

<dl><dt><b>Args:</b>
<dd>PlainText: text to be URL "escaped"
<dd>format: 0 to treat PlainText as a query string, 1 to treat it as a full URL
</dl>

<dl><dt><b>Returns:</b>
<dd>escaped text
</dl>

<p>Special characters such as spaces are not used literally in URLs.
If you want to ensure that an entire text string is sent literally, you can
"escape" those characters.  For example, a double quote (ASCII 34) is produced
by the code <code>%22</code>, where 22 is hexadecimal for 34.

<p>The <code>url_encode()</code> instruction does this for you
automatically. Using <code>format=1</code> will treat the URL as already
encoded and only re-encode characters that don't belong in the result.
Otherwise PlainText is treated as part of a query string; in this case spaces
are converted to <code>+</code> instead of <code>%20</code>, and most
characters are escaped.

<h3>Example:</h3>
<xmp>
mob/verb/Private(M as mob in players, T as text)
   if(!client || !M || !M.client || !T) return
   usr << "\[To <a href='?msg=[url_encode(M.key)]'>[M.name]</a>\] [T]"
   M << "\[From <a href='?msg=[url_encode(key)]'>[name]</a>\] [T]"
</xmp>

