

<a name=/proc/findtextEx>
<h2>findtextEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/replacetextEx>replacetextEx proc</a>
<dd><a href=#/{notes}/regex>Regular expressions</a>
</dl>

<dl><dt><b>Format:</b>
<dd>findtextEx(Haystack,Needle,Start=1,End=0)
</dl>

<dl><dt><b>Returns:</b>
<dd>The position of Needle in Haystack; 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for. May be a regular expression (regex).
<dd>Start: The text byte position in Haystack in which to begin the search.
<dd>End: The text byte position in Haystack immediately following the last
     character to search.
</dl>

<p>When Needle is text, this instruction is sensitive to the case of Haystack
and Needle.  The case-insensitive version is findtext().

<h3>Example:</h3>
<xmp>
if(findtextEx("Hi There","there")==0)
  world << "Not found!"
else
  world << "Found!"
</xmp>

<p>This outputs "Not found!", since "there" is not a part of the string "Hi
There", taking into account case.

<p>If the start or end position is negative, the position is counted backwards
from the end of the string. E.g., findtextEx("Banana", "na", -3) starts three
characters from the end and only searches the final "ana".

<p>Note: In strings containing non-ASCII characters, byte position and
character position are not the same thing. Use <tt>findtextEx_char()</tt> to
work with character counts instead of bytes, at a performance cost. See the
<a href=#/{notes}/Unicode>Unicode</a> section for more information.

<p class=compatibility>Note: This proc used to be named <tt>findText</tt>,
like <tt>findtext</tt> but with a capital T. To avoid confusion it has been
renamed, but old code will still compile.

