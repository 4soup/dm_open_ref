

<a name=/proc/findlasttextEx>
<h2 byondver=510>findlasttextEx proc</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/proc/findtext>findtext proc</a>
<dd><a href=#/proc/findtextEx>findtextEx proc</a>
<dd><a href=#/proc/findlasttext>findlasttext proc</a>
</dl>

<dl><dt><b>Format:</b>
<dd>findlasttextEx(Haystack,Needle,Start=0,End=1)
</dl>

<dl><dt><b>Returns:</b>
<dd>The last position of Needle in Haystack; 0 if not found.
</dl>

<dl><dt><b>Args:</b>
<dd>Haystack: The text string to search.
<dd>Needle: The sub-text to search for.
<dd>Start: The text byte position in Haystack in which to begin the search.
    Because this searches backwards, the default is the end of the string (0).
<dd>End: The earliest position in Haystack that can be matched as a result.
</dl>

<p>This instruction is sensitive to the case of Haystack and Needle.  The
case-insensitive version is findlasttext().

<p>If the start or end position is negative, the position is counted backwards
from the end of the string.

<p>Note: Unlike findtextEx(), a regular expression may NOT be used as the
Needle. Searching backwards is simply too complex for the regular expression
engine.

<p>Note: In strings containing non-ASCII characters, byte position and
character position are not the same thing. Use <tt>findlasttextEx_char()</tt>
to work with character counts instead of bytes, at a performance cost. See the
<a href=#/{notes}/Unicode>Unicode</a> section for more information.

