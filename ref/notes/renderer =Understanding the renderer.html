

<a name=/{notes}/renderer toc="Understanding the renderer">
<h2>Understanding the renderer</h2>

<style>
  .renderlist {position: relative; display: inline-block; margin-left: 3em; text-align: center;}
  .renderlist-label, .renderlist-caption, .renderlist-note {display: block; margin: 3px 0; width: 100%;}
  .renderlist-caption {font-size: 1.1em; font-weight: bold;}
  .renderlist-note {font-size: 0.9em;}
  .renderlist-box {background: #eee; border: 1px solid #333; padding: 3px 10px; margin: 3px 0; border-radius: 10px;}
  body.dark .renderlist-box {color: white; background: #333; border-color: #aaa;}
  .renderlist-box .renderlist-box {background: #ddd; width: 100%;}
  body.dark .renderlist-box .renderlist-box {background: #444; width: 100%;}
  .renderlist-box .renderlist-box .renderlist-box {background: #ccc;}
  body.dark .renderlist-box .renderlist-box .renderlist-box {background: #555;}
</style>

<p>To get the most out of BYOND's visual effects, it helps to understand how
the map is displayed.

<p>Every atom has an <a href=#/atom/var/appearance>appearance</a> that holds
all of its visual info (and sometimes a little non-visual info). This
appearance has to be turned into sprites in order to be rendered.

<p>Although many atoms need little more than a simple
<a class=code href=#/atom/var/icon>icon</a> and
<a class=code href=#/atom/var/icon_state>icon_state</a> and produce only a
single sprite, some are more complex with overlays, underlays, maptext, etc.
Also there may be <a href=#/image>image objects</a> and
<a href=#/atom/var/vis_contents>visual contents</a> involved, although
they're not part of the atom's appearance.

<p>For a simple <tt>icon</tt> and <tt>icon_state</tt>, just one sprite is
generated. The client looks up the icon it's given. Then it looks up an icon
state, which may be influenced by whether the atom is moving or not since you
can have moving and non-moving icon states. Then it determines which
<a href=#/atom/var/dir>direction</a> to draw and which frame of the icon's
animation (if any) to use.

<p>So with several simple icons, and not worrying about layers for now, a list
of sprites lays out like this:

<div class=renderlist>
<div class=renderlist-box>Atom #1</div>
<div class=renderlist-box>Atom #2</div>
<div class=renderlist-label>&vellip;</div>
<div class=renderlist-box>Atom #N</div>
</div>

<h3>Overlays and underlays</h3>

<p>Now let's consider what happens when an appearance has overlays.

<div class=renderlist>
<div class=renderlist-box>Underlay #1</div>
<div class=renderlist-label>&vellip;</div>
<div class=renderlist-box>Underlay #N</div>
<div class=renderlist-box>Main icon</div>
<div class=renderlist-box>Overlay #1</div>
<div class=renderlist-label>&vellip;</div>
<div class=renderlist-box>Overlay #N</div>
</div>

<p>The <a class=code href=#/atom/var/underlays>underlays</a> list is processed
first, then <a class=code href=#/atom/var/overlays>overlays</a>. These lists
contain appearances themselves, rather than actual atoms. This means that
overlays are recursive: an overlay can have overlays itself. To picture how
that works, just replace
one of the overlays above with another list.

<div class=renderlist>
<div class=renderlist-box>Underlay #1</div>
<div class=renderlist-box>Underlay #2</div>
<div class=renderlist-box>Main icon</div>
<div class=renderlist-box>Underlays of overlay #1</div>
<div class=renderlist-box>Overlay #1 icon</div>
<div class=renderlist-box>Overlays of overlay #1</div>
<div class=renderlist-box>Overlay #2</div>
</div>

<h3>Image objects and visual contents</h3>

<p>Any atom can have an <a href=#/image>image object</a> attached, which can
be shown to only specific players. Most atoms, and image objects, can have
<a href=#/atom/var/vis_contents>visual contents</a> that display other atoms
as if they're overlays.

<div class=renderlist>
<div class=renderlist-box>Underlays</div>
<div class=renderlist-box>Main icon</div>
<div class=renderlist-box>Overlays</div>
<div class=renderlist-box>Image objects</div>
<div class=renderlist-box>Visual contents</div>
</div>

<p>As you see this is very similar to overlays. Just like overlays, image
objects and visual contents have appearances of their own (and may also have
their own images or visual contents), so this may be recursive as they add
new overlays, etc.

<p>A couple of things to keep in mind:

<ul>
<li>If an image object uses the <a class=code href=#/atom/var/override>override</a>
  var, it will replace the main appearance's icon and overlays, although it
  won't replace other images or visual contents.</li>
<li>An object in visual contents can use
  <a class=code href=#/atom/var/vis_flags>vis_flags</a> to set
  <tt>VIS_UNDERLAY</tt> and move itself before the parent's underlays.</li>
</ul>

<h3>Maptext and particles</h3>

<p>Any appearance may have <a class=code href=#/atom/var/maptext>maptext</a>
attached. That maptext draws above the icon but is grouped with it. That
grouping will be discussed further below.

<p>Particle effects also get grouped with the main icon in a similar way to
maptext.

<p>For simplicity, from this point forward the diagram will just treat underlays,
overlays, image objects, and visual contents as overlays.

<div class=renderlist>
<div class=renderlist-box>
  <div class=renderlist-box>Main icon</div>
  <div class=renderlist-box>Maptext</div>
  <div class=renderlist-box>Particles</div>
</div>
<div class=renderlist-box>Overlays</div>
</div>

<h3>Color, transform, and filters</h3>

<p>An appearance's <a class=code href=#/atom/var/color>color</a> and
<a class=code href=#/atom/var/alpha>alpha</a> vars (from here forwarded
they'll just be referred to by <tt>color</tt>) and
<a class=code href=#/atom/var/transform>transform</a> are inherited by any
overlays, which also includes images and visual contents. You can avoid that
inheritance by giving those overlays special
<a class=code href=#/var/appearance_flags>appearance_flags</a>:
<tt>RESET_COLOR</tt>, <tt>RESET_ALPHA</tt>, and <tt>RESET_TRANSFORM</tt>.

<p>The appearance's filters are only applied to the main icon.

<div class=renderlist>
<div class=renderlist-box>
  <div class=renderlist-box>Main icon</div>
  <div class=renderlist-box>Maptext</div>
  <div class=renderlist-note>Main <tt>color</tt>, <tt>transform</tt>, and <tt>filters</tt> apply</div>
</div>
<div class=renderlist-box>
  <div class=renderlist-label>Overlays</div>
  <div class=renderlist-note><tt>color</tt> and <tt>transform</tt> are inherited from Main<br><tt>filters</tt> are not inherited from Main</div>
</div>
</div>

<p>When <tt>color</tt> and <tt>transform</tt> are inherited, they "stack". The
inherited color and transform values are applied after those of the overlays.

<h3><tt>KEEP_TOGETHER</tt> and <tt>KEEP_APART</tt></h3>

<p>There are times it's desirable for an appearance and all its overlays to be
treated as a single unit so any colors or filters can be applied all at once.
One simple example is if the appearance has an <tt>alpha</tt> of 128 to make it
translucent, you probably want to draw the whole atom faded instead of drawing
each sprite faded, one on top of the other.

<p>By using the <tt>KEEP_TOGETHER</tt> value in
<a class=code href=#/var/appearance_flags>appearance_flags</a> (called KT for
short), an appearance will group all of its underlays and overlays together.
If this is an atom with image objects and visual contents, those will be
grouped with it as well.

<div class=renderlist>
<div class=renderlist-box>
  <div class=renderlist-label>KT group</div>
  <div class=renderlist-note>Main <tt>color</tt>, <tt>transform</tt>, and <tt>filters</tt> apply</div>
  <div class=renderlist-box>
    <div class=renderlist-box>Main icon</div>
    <div class=renderlist-box>Maptext</div>
  </div>
  <div class=renderlist-box>Overlays</div>
</div>
</div>

<p>With <tt>KEEP_TOGETHER</tt> all of these sprites are rendered to a
temporary drawing surface, and then the main appearance's <tt>color</tt>,
<tt>transform</tt>, and <tt>filters</tt> are all applied to the combined
drawing. This comes with a trade-off, since you can no longer use flags
such as <tt>RESET_COLOR</tt> to opt out of inheritance.

<p>If an overlay doesn't want to be part of a KT group, it can use the
<tt>KEEP_APART</tt> flag (KA for short). If there are multiple nested
KT groups, KA will only escape the innermost group.

<p>If an overlay inside a KT group has a different
<a class=code href=#/atom/var/plane>plane</a> than the group's owner, it
will be separated as if it defined <tt>KEEP_APART</tt>, except it can
escape multiple nested groups.

<h3>Layers and planes</h3>

<p>Any appearance can have a <a class=code href=#/atom/var/layer>layer</a>
or <a class=code href=#/atom/var/layer>plane</a>, and these influence how
it gets sorted. (There's also a concept called a "sub-plane" that's
influenced by whether an atom is a
<a href=#/{notes}/HUD>HUD/screen object</a> or special layers like
<a class=code href=#/{notes}/BACKGROUND_LAYER>BACKGROUND_LAYER</a>.)

<p>If a sprite is created with <tt>FLOAT_LAYER</tt> (any negative value
counts as a floating layer) its layer has to be resolved, or "unfloated".
The main sprite for an atom can never float; it has to have a real layer.
Its overlays and underlays with floating layers will reorder themselves in
numerical order, then look for the next closest sprites in the rendering
list that has a non-negative layer.

<p>A similar process happens with <tt>FLOAT_PLANE</tt>. Planes can have
negative values but <TT>FLOAT_PLANE</TT> and the values close to it are
special. Sprites with floating planes have to resolve those as well.

<p>Once all atoms that will appear on the map are assembled into a rendering
list of sprites, the order in which they're rendered on the map is determined
in this order:

<ol>
  <li>The <tt>plane</tt> var matters most.</li>
  <li>Subplane is counted next. E.g., HUD objects render above non-HUD objects.</li>
  <li>Depending on <a class=code href=#/world/var/map_format>world.map_format</a>, <tt>layer</tt> or physical position determine the drawing order from here.</li>
  <li>After everything else has been checked, the order the sprites were generated in is the final tie-breaker.</li>
</ol>

<p>In a typical topdown map, <tt>layer</tt> is basically all that matters
after the plane and subplane are taken into account. There is a legacy
concept called micro-layers that helps break ties between sprites with the
same layer; for instance if an atom is moving it's usually desirable to
draw it above other atoms with the same layer; this applies only to topdown
maps.

<h3>Plane masters</h3>

<p>Sometimes it's helpful to group multiple sprites on one plane as if the
plane itself were a KT group. For this,
<a class=code href=#/var/appearance_flags>appearance_flags</a> has a value
called <tt>PLANE_MASTER</tt>. An object with this flag will act as a "parent"
for everything else on the plane. All other sprites on the plane will be
grouped together and rendered on a temporary drawing surface, and then the
plane master's <tt>color</tt>, <tt>transform</tt>, and <tt>filters</tt> will
be applied.

<p>A plane master does not, however, get an icon or maptext of its own;
they're simply ignored. It can have overlays added to the group.

<h3>Advanced topics</h3>

<p>There are other topics not covered in this article, such as
<a href=#/atom/var/render_target>render targets</a> and special map formats.
Any details on how those features impact rendering are discussed in their
own articles.

