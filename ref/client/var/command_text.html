

<a name=/client/var/command_text>
<h2 deprecated=1>command_text (client)</h2>

<dl><dt><b>See also:</b>
<dd><a href=#/verb/arguments>arguments (verb)</a>
<dd><a href=#/{skin}/param/command>command parameter</a>
<dd><a href=#/client/var/script/macro>macros (client script)</a>
<dd><a href=#/{skin}/control/input>Input control (skin)</a>
<dd><a href=#/{skin}/param/command>command parameter (skin)</a>
<dd><a href=#/{skin}/macros>macros (skin)</a>
</dl>

<dl><dt><b>Default value:</b>
<dd>null
</dl>

<p class=compatibility>Note: In BYOND 4.0 this var is deprecated. The
<a class=code href=#/{skin}/param/command>command</a> parameter for an
<a href=#/{skin}/control/input>Input control</a> can be set to
<tt>!command</tt> (<tt>!</tt> in front of your default command) which does the
same thing.

<p>This text is placed onto the command line, to be followed by whatever the
user may type.  It is usually the name of a verb followed by a space, such
as <tt>"say "</tt>.  The user can clear this and enter a different command by
hitting backspace, escape, delete, or <tt>/</tt>.

<h3>Example:</h3>
<xmp>
client
   command_text = "say "

   verb/say(T as text)
      world << "[usr] says, '[T]'"
</xmp>

<p>It is also possible to turn on macro mode, in which each keypress
executes a <a href=#/client/var/script/macro>keyboard macro</a>, by setting
<code>command_text</code> to <tt>".alt "</tt>.  That stands for the <i>Alt</i>
key, which can be used to execute macros in normal mode.

<p>This variable could also be used to create a specialized command prompt.
For example, a traditional style MUD command-line could be implemented like
this:

<h3>Example:</h3>
<xmp>
client
   command_text = "> "
   verb/command(C as command_text)
      set name = ">"
      usr << "Your command: [C]"
</xmp>

<p>This example uses the <tt>command_text</tt> input type, which accepts raw
text, with no quoting, escaping, or translating, so that you can invent
whatever syntax you want.

